#
# _author_ = Grant Curell <grant_curell@dell.com>
#
# Copyright (c) 2022 Dell EMC Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
#### Synopsis
Performs management tasks of OME SupportAssist Enterprise (SAE) groups including creating new groups, adding devices,
removing devices, and deleting groups.

#### Description

**Python Version**

Creation of groups is managed from a YML file with the argument --add-group. You can create the YML file automatically
 using the --generate-yaml <FILENAME> argument following by --add-group <FILENAME>. You can also manually complete the
yaml file by copying and pasting the below into <YOURFILE>.yml:

    ---
    Id: 0
    Name: "Your Group"
    Description: "This is a test group for supportassist enterprise"
    ContactOptIn: True
    DispatchOptIn: True
    MyAccountId: 
    CustomerDetails:
      PrimaryContact:
        FirstName: "Gelante"
        LastName: "Woxihuanxueyuyan"
        Email: "gelante@dell.com"
        Phone: "8888888888"
        AlternatePhone:
        TimeFrame: "10:00 AM-4:00 PM" # The spacing and caps do matter.
        TimeZone: "TZ_ID_71"  # This is an ID for the timezone from OME. You have to use the /api/ApplicationService/Network/TimeZones API endpoint to get it.
        ContactMethod: "phone"
      SecondaryContact:
        FirstName: "Anjila"
        LastName: "Zheshiwotaitai"
        Email: "gelante@daier.com"
        Phone: "9999999999"
        AlternatePhone:
        TimeFrame: "10:00 AM-4:00 PM"
        TimeZone: "TZ_ID_71"
        ContactMethod: "phone"
      ShippingDetails:
        PrimaryContact:
          FirstName: "Wojiarbob"
          LastName: "Nolose"
          Email: "gengduojiademingze@judadaier.com"
          Phone: "1111111111"
          AlternatePhone:
        SecondaryContact:
          FirstName: "Wotaoyan"
          LastName: "Woxuyaozuodepeixun"
          Email: "wobuguanxipeixun@gmail.com"
          Phone: "9999999999"
          AlternatePhone:
        Country: "US"
        State: "Ohio"
        City: "Centerville"
        Zip: "44444"
        Cnpj:
        Ie:
        AddressLine1: 109 Español Way
        AddressLine2: San Antonio TX
        AddressLine3: 78211
        AddressLine4:
        PreferredContactTimeZone: "TZ_ID_71"
        PreferredContactTimeFrame: "10:00 AM-4:00 PM"
        TechnicianRequired: False
        DispatchNotes: "我现在写程序但是我需要做培训。我偏好写程序."

You will need to replace all the fields with your information. This is the same as the file generated by
--generate-yaml except you will have to account for making sure it is valid yourself. This is ultimately converted to
 JSON so you could also write your own input mechanism.

**PowerShell Version**

Creation of groups is managed from a JSON file with the argument -AddGroup. You can create the JSON file automatically using the
-GenerateJson <FILENAME> argument following by -AddGroup <FILENAME>. You can also manually complete the JSON file by copying
and pasting the below into <YOURFILE>.json:

    {
      "MyAccountId": 9999999,
      "Description": "Test group from me",
      "Name": "Test Group 2",
      "DispatchOptIn": true,
      "CustomerDetails": {
        "ShippingDetails": {
          "AddressLine1": "109 Gelante Way",
          "TechnicianRequired": true,
          "PrimaryContact": {
            "LastName": "Curell",
            "Phone": "1111111111",
            "AlternatePhone": "",
            "FirstName": "Grant",
            "Email": "grant_curell@meiguo.com"
          },
          "AddressLine4": "",
          "City": "Dayton",
          "Country": "US",
          "DispatchNotes": "No",
          "State": "Ohio",
          "SecondaryContact": {
            "LastName": "Curell",
            "Phone": "9999999999",
            "AlternatePhone": "",
            "FirstName": "Angela",
            "Email": "grantcurell@wojia.com"
          },
          "Cnpj": null,
          "AddressLine3": "78210",
          "PreferredContactTimeFrame": "10:00 AM-4:00 PM",
          "Zip": "45459",
          "Ie": null,
          "PreferredContactTimeZone": "TZ_ID_65",
          "AddressLine2": "San Antonio TX"
        },
        "PrimaryContact": {
          "LastName": "Curell",
          "TimeZone": "TZ_ID_10",
          "AlternatePhone": "",
          "ContactMethod": "phone",
          "TimeFrame": "10:00 AM-4:00 PM",
          "FirstName": "Grant",
          "Phone": "8888888888",
          "Email": "daiershizuihaode@dell.com"
        },
        "SecondaryContact": {
          "LastName": "Curell",
          "TimeZone": "TZ_ID_71",
          "AlternatePhone": "",
          "ContactMethod": "phone",
          "TimeFrame": "10:00 AM-4:00 PM",
          "FirstName": "Angela",
          "Phone": "9999999999",
          "Email": "grantcurell@zheshiwotaitai.com"
        }
      },
      "ContactOptIn": true
    }

You will need to replace all the fields with your information. This is the same as the file generated by -GenerateJSON except you will have to
account for making sure it is valid yourself. This is ultimately converted to JSON so you could also write your own input mechanism.

#### Python Example
    python invoke_manage_supportassist_groups.py --ip 192.168.1.93 --user admin --password <password> --add-group "Gelante Group"
    python invoke_manage_supportassist_groups.py --ip 192.168.1.93 --user admin --password <password> --add-devices "Test Group" --idrac-ips 192.168.1.63
    python invoke_manage_supportassist_groups.py --ip 192.168.1.93 --user admin --password <password> --remove-devices "Test Group" --idrac-ips 192.168.1.63
    python invoke_manage_supportassist_groups.py --ip 192.168.1.93 --user admin --password <password> --remove-group "Test Group 2"

"""

import argparse
import json
import sys
from argparse import RawTextHelpFormatter
from getpass import getpass
from os.path import isfile
from pprint import pprint
from urllib.parse import urlparse

try:
    import urllib3
    import requests
except ModuleNotFoundError:
    print("This program requires urllib3 and requests. To install them on most systems run `pip install requests"
          "urllib3`")
    sys.exit(0)

try:
    import yaml
except ModuleNotFoundError:
    print("This program requires pyyaml. To install it run `pip install pyyaml``")
    sys.exit(0)


def authenticate(ome_ip_address: str, ome_username: str, ome_password: str) -> dict:
    """
    Authenticates with OME and creates a session

    Args:
        ome_ip_address: IP address of the OME server
        ome_username:  Username for OME
        ome_password: OME password

    Returns: A dictionary of HTTP headers

    Raises:
        Exception: A generic exception in the event of a failure to connect.
    """

    authenticated_headers = {'content-type': 'application/json'}
    session_url = 'https://%s/api/SessionService/Sessions' % ome_ip_address
    user_details = {'UserName': ome_username,
                    'Password': ome_password,
                    'SessionType': 'API'}
    try:
        session_info = requests.post(session_url, verify=False,
                                     data=json.dumps(user_details),
                                     headers=authenticated_headers)
    except requests.exceptions.ConnectionError:
        print("Failed to connect to OME. This typically indicates a network connectivity problem. Can you ping OME?")
        sys.exit(0)

    if session_info.status_code == 201:
        authenticated_headers['X-Auth-Token'] = session_info.headers['X-Auth-Token']
        return authenticated_headers

    print("There was a problem authenticating with OME. Are you sure you have the right username, password, "
          "and IP?")
    raise Exception("There was a problem authenticating with OME. Are you sure you have the right username, "
                    "password, and IP?")


def post_data(url: str, authenticated_headers: dict, payload: dict, error_message: str) -> dict:
    """
    Posts data to OME and returns the results

    Args:
        url: The URL to which you want to post
        authenticated_headers: Headers used for authentication to the OME server
        payload: A payload to post to the OME server
        error_message: If the POST fails this is the message which will be displayed to the user

    Returns: A dictionary with the results of the post request or an empty dictionary in the event of a failure. If the
             result is a 204 - No Content (which indicates success but there is no data) then it will return a
             dictionary with the value {'status_code': 204}

    """
    response = requests.post(url, headers=authenticated_headers, verify=False, data=json.dumps(payload))

    if response.status_code == 204:
        return {'status_code': 204}
    if response.status_code != 400:
        return json.loads(response.content)
    else:
        print(error_message + " Error was:")
        pprint(json.loads(response.content))
        return {}


def get_data(authenticated_headers: dict, url: str, odata_filter: str = None, max_pages: int = None) -> dict:
    """
    This function retrieves data from a specified URL. Get requests from OME return paginated data. The code below
    handles pagination. This is the equivalent in the UI of a list of results that require you to go to different
    pages to get a complete listing.

    Args:
        authenticated_headers: A dictionary of HTTP headers generated from an authenticated session with OME
        url: The API url against which you would like to make a request
        odata_filter: An optional parameter for providing an odata filter to run against the API endpoint.
        max_pages: The maximum number of pages you would like to return

    Returns: Returns a dictionary of data received from OME

    """

    next_link_url = None

    if odata_filter:
        count_data = requests.get(url + '?$filter=' + odata_filter, headers=authenticated_headers, verify=False)

        if count_data.status_code == 400:
            print("Received an error while retrieving data from %s:" % url + '?$filter=' + odata_filter)
            pprint(count_data.json()['error'])
            return {}

        count_data = count_data.json()
        if count_data['@odata.count'] <= 0:
            print("No results found!")
            return {}
    else:
        count_data = requests.get(url, headers=authenticated_headers, verify=False).json()

    if 'value' in count_data:
        data = count_data['value']
    else:
        data = count_data

    if '@odata.nextLink' in count_data:
        # Grab the base URI
        next_link_url = '{uri.scheme}://{uri.netloc}'.format(uri=urlparse(url)) + count_data['@odata.nextLink']

    i = 1
    while next_link_url is not None:
        # Break if we have reached the maximum number of pages to be returned
        if max_pages:
            if i >= max_pages:
                break
            else:
                i = i + 1
        response = requests.get(next_link_url, headers=authenticated_headers, verify=False)
        next_link_url = None
        if response.status_code == 200:
            requested_data = response.json()
            if requested_data['@odata.count'] <= 0:
                print("No results found!")
                return {}

            # The @odata.nextLink key is only present in data if there are additional pages. We check for it and if it
            # is present we get a link to the page with the next set of results.
            if '@odata.nextLink' in requested_data:
                next_link_url = '{uri.scheme}://{uri.netloc}'.format(uri=urlparse(url)) + \
                                requested_data['@odata.nextLink']

            if 'value' in requested_data:
                data += requested_data['value']
            else:
                data += requested_data
        else:
            print("Unknown error occurred. Received HTTP response code: " + str(response.status_code) +
                  " with error: " + response.text)
            raise Exception("Unknown error occurred. Received HTTP response code: " + str(response.status_code)
                            + " with error: " + response.text)

    return data


def get_device_id(authenticated_headers: dict,
                  ome_ip_address: str,
                  service_tag: str = None,
                  device_idrac_ip: str = None,
                  device_name: str = None) -> int:
    """
    Resolves a service tag, idrac IP or device name to a device ID

    Args:
        authenticated_headers: A dictionary of HTTP headers generated from an authenticated session with OME
        ome_ip_address: IP address of the OME server
        service_tag: (optional) The service tag of a host
        device_idrac_ip: (optional) The idrac IP of a host
        device_name: (optional): The name of a host

    Returns: Returns the device ID or -1 if it couldn't be found
    """

    if not service_tag and not device_idrac_ip and not device_name:
        print("No argument provided to get_device_id. Must provide service tag, device idrac IP or device name.")
        return -1

    # If the user passed a device name, resolve that name to a device ID
    if device_name:
        device_id = get_data(authenticated_headers, "https://%s/api/DeviceService/Devices" % ome_ip_address,
                             "DeviceName eq \'%s\'" % device_name)
        if len(device_id) == 0:
            print("Error: We were unable to find device name " + device_name + " on this OME server. Exiting.")
            return -1

        device_id = device_id[0]['Id']

    elif service_tag:
        device_id = get_data(authenticated_headers, "https://%s/api/DeviceService/Devices" % ome_ip_address,
                             "DeviceServiceTag eq \'%s\'" % service_tag)

        if len(device_id) == 0:
            print("Error: We were unable to find service tag " + service_tag + " on this OME server. Exiting.")
            return -1

        device_id = device_id[0]['Id']

    elif device_idrac_ip:
        device_id = -1
        device_ids = get_data(authenticated_headers, "https://%s/api/DeviceService/Devices" % ome_ip_address,
                              "DeviceManagement/any(d:d/NetworkAddress eq '%s')" % device_idrac_ip)

        if len(device_ids) == 0:
            print("Error: We were unable to find idrac IP " + device_idrac_ip + " on this OME server. Exiting.")
            return -1

        # TODO - This is necessary because the filter above could possibly return multiple results
        # TODO - See https://github.com/dell/OpenManage-Enterprise/issues/87
        for device_id in device_ids:
            if device_id['DeviceManagement'][0]['NetworkAddress'] == device_idrac_ip:
                device_id = device_id['Id']

        if device_id == -1:
            print("Error: We were unable to find idrac IP " + device_idrac_ip + " on this OME server. Exiting.")
            return -1
    else:
        device_id = -1

    return device_id


def query_yes_no(question: str, default: str = "yes") -> bool:
    """
    Prompts the user with a yes/no question

    Args:
        question: The question to ask the user
        default: Whether the default answer is no or yes. Defaults to yes

    Returns: A boolean - true if yes and false if no

    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")


def get_timezone(authenticated_headers: dict, ome_ip_address: str) -> dict:
    """
    Gets a list of the available timezones on the OME instance

    Args:
        authenticated_headers: A dictionary of HTTP headers generated from an authenticated session with OME
        ome_ip_address: IP address of the OME server

    Returns: Returns a dictionary containing the timezones on the OME server or an empty dictionary if there
             was a problem.

    """
    timezones = get_data(authenticated_headers, "https://%s/api/ApplicationService/Network/TimeZones" % ome_ip_address)

    if not timezones:
        print("There was a problem retreiving the time zones! Exiting.")
        return {}

    return timezones


def confirm_isvalid(output_filepath: str = "", input_filepath: str = "") -> bool:
    """
    Tests whether a filepath is valid or not. You can only provide either input_filepath or output_filepath. Not both.

    Args:
        output_filepath: The path to an output file you want to test
        input_filepath:The path to an input file you want to test

    Returns:
        Returns true if the path is valid and false if it is not
    """

    if input_filepath != "" and output_filepath != "":
        print("You can only provide either an InputFilePath or an OutputFilePath.")
        sys.exit(0)

    if isfile(output_filepath):
        if not query_yes_no(output_filepath + " already exists? Do you want to continue? (y/n): ", "no"):
            return False

    if output_filepath:
        try:
            open(output_filepath, 'w')
        except OSError:
            print("The filepath %s does not appear to be valid. This could be due to an incorrect path or a permissions"
                  " issue." % output_filepath)
            return False

    if input_filepath:
        try:
            open(input_filepath, 'r')
            return True
        except OSError:
            print("The filepath %s does not appear to be valid. This could be due to an incorrect path or a permissions"
                  " issue." % input_filepath)
            return False


def create_group_creation_payload(authenticated_headers: dict, ome_ip_address: str) -> dict:
    """
    Prompts the user for each field required to create the group

    Args:
        authenticated_headers: A dictionary of HTTP headers generated from an authenticated session with OME
        ome_ip_address: IP address of the OME server

    Returns: a dictionary containing all the data required to generate the group

    """

    user_data_dictionary = {'Name': input("Group Name: "),
                            'Description': input("Description: "),
                            'ContactOptIn': query_yes_no(
                                "Do you want to be contacted regarding this group? This will also opt you "
                                "into dispatches."),
                            'MyAccountId': int(input("Account ID (only numbers): ")),
                            'CustomerDetails': None}

    if user_data_dictionary['ContactOptIn']:
        user_data_dictionary['DispatchOptIn'] = True

        customer_details = {}
        timezones = get_timezone(authenticated_headers, ome_ip_address)

        if not timezones:
            return {}

        def _prompt_for_contact_details(prompt_text: str) -> dict:

            data_dictionary = {'FirstName': input(prompt_text + " Contact First Name: "),
                               'LastName': input(prompt_text + "Contact Last Name: "),
                               'Email': input(prompt_text + "Contact Email: "),
                               'Phone': input(prompt_text + "Contact Phone: "),
                               'AlternatePhone': input(prompt_text + "Contact Alternate Phone: ")}

            return data_dictionary

        # Primary Contact
        customer_details['PrimaryContact'] = _prompt_for_contact_details('Primary')
        customer_details['PrimaryContact']['ContactMethod'] = 'phone'
        customer_details['PrimaryContact']['TimeFrame'] = input("Primary Contact time frame in the format: "
                                                                "10:00 AM-4:00 PM.  WARNING: There is no "
                                                                "input validation on this. You must match"
                                                                " caps and spacing. : ")

        for timezone in timezones:
            print("Name: %s Id: %s" % (timezone['Name'], timezone['Id']))
        customer_details['PrimaryContact']['TimeZone'] = input("Primary contact timezone. Input timezone ID. (Make "
                                                               "sure to match exactly): ")

        # Secondary Contact
        customer_details['SecondaryContact'] = _prompt_for_contact_details('Secondary')
        customer_details['SecondaryContact']['TimeFrame'] = input("Secondary Contact time frame in the format: "
                                                                  "10:00 AM-4:00 PM.  WARNING: There is no "
                                                                  "input validation on this. You must match"
                                                                  " caps and spacing. : ")

        for timezone in timezones:
            print("Name: %s Id: %s" % (timezone['Name'], timezone['Id']))
        customer_details['SecondaryContact']['TimeZone'] = input("Secondary contact timezone. Input timezone ID. "
                                                                 "(Make sure to match exactly): ")

        customer_details['SecondaryContact']['ContactMethod'] = 'phone'

        # Shipping Details Primary Contact
        customer_details['ShippingDetails'] = {}
        customer_details['ShippingDetails']['PrimaryContact'] = _prompt_for_contact_details(
            'Shipping Primary Contact: ')
        customer_details['ShippingDetails']['SecondaryContact'] = _prompt_for_contact_details(
            'Shipping Secondary Contact: ')

        # Country
        customer_details['ShippingDetails']['Country'] = "US"  # TODO - need to add support for other countries
        customer_details['ShippingDetails']['State'] = input("State: ")
        customer_details['ShippingDetails']['City'] = input("City: ")
        customer_details['ShippingDetails']['Zip'] = input("Zip: ")
        customer_details['ShippingDetails']['Cnpj'] = None
        customer_details['ShippingDetails']['Ie'] = None
        customer_details['ShippingDetails']['AddressLine1'] = input("Address Line 1: ")
        customer_details['ShippingDetails']['AddressLine2'] = input("Address Line 2: ")
        customer_details['ShippingDetails']['AddressLine3'] = input("Address Line 3: ")
        customer_details['ShippingDetails']['AddressLine4'] = input("Address Line 4: ")

        customer_details['ShippingDetails']['PreferredContactTimeFrame'] = input("Shipping contact time frame in the "
                                                                                 "format: 10:00 AM-4:00 PM.  WARNING: "
                                                                                 "There is no input validation on this."
                                                                                 " You must match caps and spacing. : ")

        for timezone in timezones:
            print("Name: %s Id: %s" % (timezone['Name'], timezone['Id']))
        customer_details['ShippingDetails']['PreferredContactTimeZone'] = input("Shipping contact timezone. Input "
                                                                                "timezone ID. (Make sure to match "
                                                                                "exactly): ")

        customer_details['ShippingDetails']['TechnicianRequired'] = query_yes_no("Is a technician required for "
                                                                                 "dispatches?")

        customer_details['ShippingDetails']['DispatchNotes'] = input('Any dispatch notes you want to add to '
                                                                     'devices in this group: ')

        user_data_dictionary['CustomerDetails'] = customer_details

    else:
        user_data_dictionary['DispatchOptIn'] = False

    return user_data_dictionary


def get_group_id_by_name(authenticated_headers: dict, ome_ip_address: str, group_name: str) -> int:
    """
    Resolves the name of a group to an ID

    Args:
        authenticated_headers: A dictionary of HTTP headers generated from an authenticated session with OME
        ome_ip_address: IP address of the OME server
        group_name: The name of the group to be resolved

    Returns: The ID of the group or -1 if it couldn't be found

    """

    print("Looking up ID for group " + group_name)

    ome_group_url = "https://%s/api/GroupService/Groups" % ome_ip_address
    groups = get_data(authenticated_headers, ome_group_url, "Name eq '%s'" % group_name)

    if len(groups) < 1:
        print("Error: We were unable to find a group matching the name %s." % args.group_name)
        return -1

    return groups[0]['Id']


if __name__ == '__main__':
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    parser = argparse.ArgumentParser(description=__doc__, formatter_class=RawTextHelpFormatter)
    parser.add_argument("--ip", "-i", required=True, help="OME Appliance IP")
    parser.add_argument("--user", "-u", required=False,
                        help="Username for the OME Appliance", default="admin")
    parser.add_argument("--password", "-p", required=False,
                        help="Password for the OME Appliance")
    parser.add_argument("--device-ids", "-d", help="A comma separated list of device-ids which you want to add to a "
                                                   "group.")
    parser.add_argument("--service-tags", "-s", help="A comma separated list of service tags which you want to add "
                                                     "to a group.")
    parser.add_argument("--idrac-ips", "-r", help="A comma separated list of idrac IPs which you want to add to a "
                                                  "group.")
    parser.add_argument("--device-names", "-n", help="A comma separated list of device names which you want to add "
                                                     "to a group.")
    parser.add_argument("--use-discovery-job-id", required=False,
                        help="This option allows you to provide the job ID"
                             " from a discovery job and will pull the servers from that job ID and assign them to the "
                             "specified group. You can either retrieve the job ID programatically or you can get it "
                             "manually from the UI by clicking on the job and pulling it from the URL. Ex: "
                             "https://192.168.1.93/core/console/console.html#/core/monitor/monitor_portal/jobsDetails?jobsId=14026")
    mutex_group = parser.add_mutually_exclusive_group(required=True)
    mutex_group.add_argument("--generate-yaml", help="Generate a YAML file which can be used as input to create the "
                                                     "SupportAssist Enterprise group. Provide the name of the output"
                                                     " YAML as an argument.")
    mutex_group.add_argument("--add-group", help="Create a new SupportAssist Enterprise group. You must "
                                                 "provide the name of the YAML file with your input"
                                                 " settings as an argument.")
    mutex_group.add_argument("--remove-group", help="Remove a SupportAssist Enterprise group. Provide the name of the"
                                                    " group which you would like to remove with this option.")
    mutex_group.add_argument("--add-devices", help="Add the specified devices to the SupportAssist Enterprise group. "
                                                   "Specify the device IDs with --device-ids, --service-tags, "
                                                   "--idrac-ips, --device-names, or --use-discovery-job-id. The "
                                                   "--add-devices option accepts the name of the group to which you "
                                                   "want to add devices as an argument.")
    mutex_group.add_argument("--remove-devices", help="Remove the specified devices from the SupportAssist Enterprise "
                                                      "group. Specify the device IDs with --device-ids, "
                                                      "--service-tags, --idrac-ips, --device-names, or "
                                                      "--use-discovery-job-id. The --remove-devices option accepts the"
                                                      " name of the group to which you want to remove devices as an "
                                                      "argument.")

    args = parser.parse_args()

    if not args.password:
        if not sys.stdin.isatty():
            # notify user that they have a bad terminal
            # perhaps if os.name == 'nt': , prompt them to use winpty?
            print("Your terminal is not compatible with Python's getpass module. You will need to provide the"
                  " --password argument instead. See https://stackoverflow.com/a/58277159/4427375")
            sys.exit(0)
        else:
            password = getpass()
    else:
        password = args.password

    try:

        headers = authenticate(args.ip, args.user, args.password)

        if not headers:
            sys.exit(0)

        target_ids = []

        if args.device_ids:
            device_ids_arg = args.device_ids.split(',')
        else:
            device_ids_arg = None

        if args.service_tags:
            service_tags = args.service_tags.split(',')
            for service_tag in service_tags:
                target = get_device_id(headers, args.ip, service_tag=service_tag)
                if target != -1:
                    target_ids.append(target)
                else:
                    print("Could not resolve ID for: " + service_tag)
        else:
            service_tags = None

        if args.idrac_ips:
            device_idrac_ips = args.idrac_ips.split(',')
            for device_idrac_ip in device_idrac_ips:
                target = get_device_id(headers, args.ip, device_idrac_ip=device_idrac_ip)
                if target != -1:
                    target_ids.append(target)
                else:
                    print("Could not resolve ID for: " + device_idrac_ip)
        else:
            device_idrac_ips = None

        if args.device_names:
            device_names = args.device_names.split(',')
            for device_name in device_names:
                target = get_device_id(headers, args.ip, device_name=device_name)
                if target != -1:
                    target_ids.append(target)
                else:
                    print("Could not resolve ID for: " + device_name)
        else:
            device_names = None

        if args.use_discovery_job_id:
            job_info = get_data(headers, "https://%s/api/JobService/Jobs(%s)" % (args.ip, args.use_discovery_job_id))

            if 'ExecutionHistories@odata.navigationLink' in job_info:
                job_info = get_data(headers, "https://" + args.ip + job_info['ExecutionHistories@odata.navigationLink'])
            else:
                print("Error: Something went wrong getting the job with ID " + str(args.args.use_discovery_job_id))
                sys.exit(0)

            if 'ExecutionHistoryDetails@odata.navigationLink' in job_info[0]:
                details_url = "https://" + args.ip + job_info[0]['ExecutionHistoryDetails@odata.navigationLink']
                job_info = get_data(headers, details_url)
            else:
                print("Error: Something went wrong getting the execution details")
                sys.exit(0)

            if len(job_info) > 0:
                for host in job_info:
                    target = get_device_id(headers, args.ip, device_idrac_ip=host['Key'])
                    if target != -1:
                        target_ids.append(target)
                    else:
                        print("Could not resolve ID for: " + host['Key'])
            else:
                print("The job info array returned empty. Exiting.")
                sys.exit(0)

        # Eliminate any duplicate IDs in the list
        target_ids = list(dict.fromkeys(target_ids))

        if (args.add_devices or args.remove_devices) and len(target_ids) < 1:
            print("Error: No IDs found. Did you provide a device to add or remove?")
            sys.exit(0)

        group_url = "https://%s/api/SupportAssistService/Actions/SupportAssistService.%s"

        if args.generate_yaml:
            print("Running generate YAML...")

            if not confirm_isvalid(output_filepath=args.generate_yaml):
                sys.exit(0)
            with open(args.generate_yaml, 'w') as output_file:
                user_data = create_group_creation_payload(headers, args.ip)
                yaml.dump(user_data, output_file)

        elif args.add_group:

            print("Creating new group...")

            add_group_url = group_url % (args.ip, "CreateOrUpdateGroup")

            if not confirm_isvalid(input_filepath=args.add_group):
                sys.exit(0)
            with open(args.add_group) as input_file:
                data = yaml.load(input_file, Loader=yaml.FullLoader)

                if not data['ContactOptIn'] and not data['DispatchOptIn']:
                    data['CustomerDetails'] = None

            response = post_data(add_group_url, headers, data,
                                 "There was a problem adding the group to the SupportAssist groups.")

            if response:
                pprint(response)
                print("Group added successfully!")
            else:
                sys.exit(0)

        elif args.remove_group:

            print("Removing group with name %s from SupportAssist Enterprise groups" % args.remove_group)

            remove_group_url = group_url % (args.ip, "DeleteGroup")

            group_id = get_group_id_by_name(headers, args.ip, args.remove_group)

            if group_id == -1:
                sys.exit(0)

            response = post_data(remove_group_url, headers, {"GroupId": group_id},
                                 "Error! There was a problem removing the group with name %s!" % args.remove_group)

            if response:
                pprint(response)
                print("Group removed successfully!")
            else:
                sys.exit(0)

        elif args.add_devices:

            print("Adding devices to the group " + args.add_devices)

            add_devices_url = group_url % (args.ip, "AddMemberDevices")

            group_id = get_group_id_by_name(headers, args.ip, args.add_devices)

            if group_id == -1:
                sys.exit(0)

            response = post_data(add_devices_url, headers, {"GroupId": group_id, "MemberDeviceIds": target_ids},
                                 "Error! There was a problem removing the group with name %s!" % args.add_devices)

            if response:
                pprint(response)
                print("Devices added successfully!")
            else:
                sys.exit(0)

        elif args.remove_devices:

            print("Removing devices from the group " + args.remove_devices)

            remove_devices_url = group_url % (args.ip, "RemoveMemberDevices")

            group_id = get_group_id_by_name(headers, args.ip, args.remove_devices)

            if group_id == -1:
                sys.exit(0)

            response = post_data(remove_devices_url, headers, {"GroupId": group_id, "MemberDeviceIds": target_ids},
                                 "Error! There was a problem removing the group with name %s!"
                                 % args.remove_devices)

            if response:
                pprint(response)
                print("Devices removed from group successfully!")
            else:
                sys.exit(0)

    except Exception as error:
        pprint(error)
